

\section{Rust}

% FIXME
\subsection{aside: why do people like C/C++?}
\input{../betterpl/why-ccpp}
% FIXME

\subsection{safety + escape hatch}
\input{../betterpl/safe-plus-escape-hatch}

\input{../betterpl/java-escape-hatch}

\subsection{general philosophy}
\input{../betterpl/rust-general}

\subsection{general syntax (1)}
\input{../betterpl/rust-syntax-basic}

\subsection{functions for types}
\input{../betterpl/rust-syntax-impl}

\subsection{references}
\subsubsection{basic example}
\input{../betterpl/rust-refs}

\subsubsection{in context}
\input{../betterpl/rust-ex-with-refs}

% FIXME: refs example with struct
\subsection{references in structs}
\input{../betterpl/rust-ex-with-refs-struct}

\subsection{basic ownership}
\input{../betterpl/rust-ownership}

\subsection{exercise}
\input{../betterpl/rust-ownership-exer}

\section{Rust: stopping dangling pointers}
\input{../betterpl/rust-no-dangle-rules}

\subsection{borrowing}
\input{../betterpl/rust-borrowing}

\subsection{exercise}
\input{../betterpl/rust-no-dangle-rules-apply}


\subsection{lifetimes}
\subsubsection{motivation}
\input{../betterpl/why-lifetimes}

\subsubsection{lifetime tracking}
\againframe<2>{dangleRules}
\input{../betterpl/rust-lifetimes}

\subsection{one writer}
\againframe<3>{dangleRules}
\input{../betterpl/rust-one-writer}

\section{destructors}
\input{../betterpl/rust-auto-drop}

\section{Rust: escape hatches and supporting dynamic allocation}
\input{../betterpl/dynamic-alloc-basic}

\subsection{escape hatches implementing Vec}
\input{../betterpl/rust-escape-inside-vec}

\subsection{raw pointers}
\input{../betterpl/rust-raw-pointers}

% FIXME: RefCell

\subsection{implementing new sharing schemes}
\subsubsection{Rc}
\input{../betterpl/rust-impl-rc}

\subsection{non-Rust smart pointers}
\input{../betterpl/cpp-smart-pointer}

\subsubsection{RefCell}
\input{../betterpl/rust-impl-refcell}

\subsection{aside: concurrency + UAF}
\input{../uaf/linux-conc-uaf}

\subsection{concurrency}
\input{../betterpl/rust-concurrency}

\section{aside: other language enforcement?}
\input{../betterpl/other-things-lang-enforce}

% FIXME: example of concurrency based exploit in Linux

\subsection{other Rust smart pointers}
\input{../betterpl/other-rust-smartptr}

\subsection{exercise: smart pointer use case}
\input{../betterpl/which-smartptr-exer}


\section{zero-overhead}
\input{../betterpl/zero-overhead-p}

\section{aside: other language enforcement?}
\input{../betterpl/other-things-lang-enforce}

\subsection{example: constant time languages}
\input{../betterpl/fact}

