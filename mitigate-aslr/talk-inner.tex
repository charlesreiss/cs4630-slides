

\section{ASLR}
\input{../mitigate-aslr/aslr-preview}

\subsection{what it is}
\input{../mitigate-aslr/aslr}

\subsection{how much entropy}
\input{../mitigate-aslr/aslr-entropy}

\subsection{entropy exercise?}
\input{../mitigate-aslr/entropy-exer}

\subsection{info leak}
\input{../mitigate-aslr/info-disc-stack-addr-exer}
    % FIXME: multiple good guesses

\subsection{kept together: danger of leaks}
\input{../mitigate-aslr/aslr-entropy-together}
\input{../mitigate-aslr/aslr-leaks}

\subsection{exercise: using a leak}
\input{../mitigate-aslr/aslr-using-leak-exer}

\subsection{exercise: using a leak (2)}
\input{../mitigate-aslr/aslr-using-leak-exer2}

\section{ASLR cost/history}
\begin{frame}{why not always ASLR?}
    \begin{itemize}
    \item ASLR seems like no-brainer
        \begin{itemize}
        \item have to choose address anyway
        \item why not choose at random?
        \end{itemize}
    \item big problem: performance/code size impacts
    \item (smaller problem: inconsistent behavior when bugs)
    \end{itemize}
\end{frame}

\subsection{Unix PIC history}
\input{../mitigate-aslr/unix-pic-history}

\subsection{alternate approach: Windows}
\input{../mitigate-aslr/aslr-windows-pic}

\subsection{exercise: without absolute addresses?}
\input{../mitigate-aslr/aslr-without-abs-ex}

\subsubsection{changes with position-independent code}
\input{../mitigate-aslr/pic-cost-code}

\subsubsection{recall: vtable pointers?}
\input{../mitigate-aslr/reloc-vtable}

\subsection{PIE / PIC}
\input{../mitigate-aslr/aslr-pie}

\subsection{PIC cost measurements}
\input{../mitigate-aslr/pic-cost-measure}
