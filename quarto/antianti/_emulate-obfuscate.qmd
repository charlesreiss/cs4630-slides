
### emulation based obfuscation 

* so far: always producing machine code and running it
* analyzing machine code with virtual machine, debugger, etc. 
<hr class="vspace" />
* alternate idea: invent a new instruction set
* convert program to that instruction set
* include interpreter for that instruction set

### example: Tigress Virtualize transform 

* Tigress generates instruction set for stack-based machine 
   * opcodes for each math operation/function original code calls
   * opcodes to copy to/from array of local variables
* instructions can pop+push from a stack for temporaries
   * similar to postfix calculator in usage


### example: Tigress Virtualize transform

example input: 
```c
int example(int x) {
    if (x > 10) {
        printf("Yes!\n");
    }   
}
```

output sketch:
```c
long code[] = {...};
long pc = 0;
while (pc != -1) {
  pc = runInstruction(code[pc]);
}
```

### example: Tigress emulator


```c
  _1_example_$sp[0] = _1_example_$stack[0];
  _1_example_$pc[0] = _1_example_$array[0];
  while (1) {
    switch (*(_1_example_$pc[0])) {
    ...
    }
  }

```

* pc variable representing emulated stack 
   * switch statement based on opcode
* sp variable representing emulated stack


### effectiveness of this transformation? 


* huge performance impact
* can do analysis on new instruction set
   * how much more difficult than working with original machine code?
* instruction traces still helpful
   * about as easy to get record of everything done


