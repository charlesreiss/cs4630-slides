
### traces instead of unpacked code 


* instead of matching signatures on code at rest
* can match signature on <i>trace</i> of executed instructions


### using instruction traces (1)  {.smaller}



* instruction traces are huge…
 
```
0x10: add %rax, %rbx
0x12: mov 0x140(%rbx), %rsi
0x14: mov %rsi, 0x150(%rbx)
0x16: jle 0x10
0x10: add %rax, %rbx        /* duplicate of before */
0x12: mov 0x140(%rbx), %rsi
0x14: mov %rsi, 0x150(%rbx)
0x16: jle 0x10
0x18: mov $10, %rcx
...

```
 

* but can simplify: e.g. remove duplicates (loops)


### using instruction traces (2)  {.smaller}



* elegant way to analyze ‘tricky’ techniques
* self-modifying code:
 
```
    0x10: add %rax, %rbx
    0x12: mov 0x140, %rax
    0x14: mov %rsp, 0x0C
        /* modifies code we will execute */
    0x16: jle 0x10
    0x10: sub %rcx, %rdx
    0x12: ...

```
 

* multiple layers of ‘decrypters’/code generation
* …

