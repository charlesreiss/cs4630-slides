
### C++ has ‘smart pointers’  {.smaller}


* probably what inspired Rust Box, Rc, etc. 
<hr class="vspace" />
* <code>std::shared_ptr</code> (like Rc), <code>std::unique_ptr</code> (like Box) 

   * like Rust Deref/DerefMut, implement <code>operator*</code> and <code>operator-></code> to act like ‘normal’ pointers

* like Rust, internally return temporary real references/pointers 
<hr class="vspace" />
* problem: no compiler enforcement of ownership rules
* can accidentally use ‘temporary’ reference/pointer for too long

### C++ unique_ptr example (1)

C++
```cpp
unique_ptr<int> p{new int};
*p = 10;
unique_ptr<int> q(move(p)};
*q = 20;
// would be error: *p
```
<hr />
```rust
let temp: Box<i32>;
let p: &mut i32 = &temp;
*p = 10;
let q: &mut i32 = p;
*q = 20;
// would be error: *p
```


### C++ unique_ptr example (2)

C++:
```cpp
unique_ptr<array<int, 4>>
add1(unique_ptr<array<int, 4>> v) {
    for (int i = 0; i < 4; i += 1) {
        v[i] += 1;
    }
    return v;
}
```
<hr />
Rust:
```rust
fn add1(v: [i32; 4]) -> [i32; 4] {
    for i in 0..4 {
        v[i] += 1;
    }
    return v;
}
```

### C++ shared_ptr example {.smaller}

C++
```cpp
vector<shared_ptr<int>> values;
values.push_back(make_shared<int>(10));
values.push_back(make_shared<int>(20));
shared_ptr<int> p{values[0]};
shared_ptr<int> q{values[0]};
cout << *p << " " << *q << *values[0] << endl; // 10 10 10
cout << values[0].use_count() << endl; // 3
cout << values[1].use_count() << endl; // 1
values.clear();
cout << p.use_count() << endl; // 2
p.reset(new int(30));
cout << q.use_count() << endl; // 1
```
<hr/>
Rust
```rust
let values: Vec<Arc<i32>> = vec![];
values.push(Arc::new(10));
values.push(Arc::new(20));
let mut p: Arc<i32> = Arc::clone(&values[0]);
let q: Arc<i32> = Arc::clone(&values[0]);
println!("{} {} {}", *p, *q, *values[0]); // 10 10 10
println!("{}", Arc::strong_count(&values[0])); // 3
println!("{}", Arc::strong_count(&values[1])); // 1
values.clear();
println!("{}", Arc::strong_count(&p)); // 2
p = Arc::new(30);
println!("{}", Arc::strong_count(&q)); // 1
```







### reference counting elsewhere  {.smaller}

* a lot of programs do manual reference counting 
   * example: lots of stuff in Linux kernel
* Swift, Perl, Python implicitly do reference counting for ‘normal’ references 
   * means normal references not ‘zero-overhead’
   * more predictable object deallocation than ‘normal’ garbage collection


