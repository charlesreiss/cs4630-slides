
### C++ has ‘smart pointers’  {.smaller}


* probably what inspired Rust Box, Rc, etc. 
<hr class="vspace" />
* <code>std::shared_ptr</code> (like Rc), <code>std::unique_ptr</code> (like Box) 

   * like Rust Deref/DerefMut, implement <code>operator*</code> and <code>operator-></code> to act like ‘normal’ pointers

* like Rust, internally return temporary real references/pointers 
<hr class="vspace" />
* problem: no compiler enforcement of ownership rules
* can accidentally use ‘temporary’ reference/pointer for too long

### C++ unique_ptr example (1) {.smaller}

:::: {.columns}

::: {.column width="48%"}

raw pointers:
```cpp
unsigned *f1a() {
    unsigned *value = new unsigned(0);
    *value += 1;
    q(*value);
    return value;
}

unsigned *f1b() {
    unsigned *value = new unsigned(0);
    *value += 1;
    q(*value);
    delete value;
}
```

:::

::: {.column width="48%"}

unique_ptr:
```cpp
unique_ptr<unsigned> f1a() {
    unique_ptr<unsigned> value{new unsigned(0)};
    *value += 1;
    q(*value);
    return value;
}

unsigned *f1b() {
    unique_ptr<unsigned> value{new unsigned(0)}
    *value += 1;
    q(*value);
    // value implicitly deleted (freed) here
}
```

:::

::::


### C++ unique_ptr example (2)

::::: {.columns}

::: {.column}

C++
```cpp
unique_ptr<int> p{new int};
*p = 10;
unique_ptr<int> q(move(p)};
*q = 20;
// would be error: *p
```

:::

::: {column}

Rust
```rust
let temp: Box<i32>;
let p: &mut i32 = &temp;
*p = 10;
let q: &mut i32 = p;
*q = 20;
// would be error: *p
```

:::


### C++ shared_ptr example {.smaller}

C++
```cpp
vector<shared_ptr<int>> values;
values.push_back(make_shared<int>(10));
values.push_back(make_shared<int>(20));
shared_ptr<int> p{values[0]};
shared_ptr<int> q{values[0]};
*p += 1;
cout << *p << " " << *q << " " << *values[0] << endl; // 11 11 11
cout << values[0].use_count() << endl; // 3
cout << values[1].use_count() << endl; // 1
values.clear();
cout << p.use_count() << endl; // 2
p.reset(new int(30));
cout << q.use_count() << endl; // 1
```
<hr/>
Rust
```rust
let mut values: Vec<Arc<Cell<i32>>> = vec![];
values.push(Arc::new(Cell::new(10)));
values.push(Arc::new(Cell::new(20)));
let mut p: Arc<Cell<i32>> = Arc::clone(&values[0]);
let q: Arc<Cell<i32>> = Arc::clone(&values[0]);
(*p).replace((*p).get() + 1);
println!("{} {} {}", (*p).get(), (*q).get(), (*values[0]).get()); // 11 11 11
println!("{}", Arc::strong_count(&values[0])); // 3
println!("{}", Arc::strong_count(&values[1])); // 1
values.clear();
println!("{}", Arc::strong_count(&p)); // 2
p = Arc::new(Cell::new(30));
println!("{}", Arc::strong_count(&q)); // 1
```







### reference counting elsewhere  {.smaller}

* a lot of programs do manual reference counting 
   * example: lots of stuff in Linux kernel
* Swift, Perl, Python implicitly do reference counting for ‘normal’ references 
   * means normal references not ‘zero-overhead’
   * more predictable object deallocation than ‘normal’ garbage collection


