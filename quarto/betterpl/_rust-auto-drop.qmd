
### Rust dropping (1)  {.smaller}


```rust
struct Example {}

impl Drop for Example {
    fn drop(&mut self) {
        println!("in Example's drop")
    }
}

fn main() {
    {
        let t = Example {};
        println!("A");
    }
    println!("B");
}

```
 output: A(newline)in Example's drop(newline)B

### Rust dropping (2)  {.smaller}


```rust
struct Example {}

impl Drop for Example {
    fn drop(&mut self) {
        println!("in Example's drop")
    }
}

fn main() {
    let q: Example;
    {
        let t = Example {};
        println!("A");
        q = t;
    }
    println!("B");
}

```
 output: A(newline)B(newline)in Example's drop

### Rust dropping (3)  {.smaller}


```rust
#[derive(Clone)] struct Example {}

impl Drop for Example {
    fn drop(&mut self) {
        println!("in drop")
    }
}

fn main() {
    let q: Example;
    {
        let t = Example {};
        println!("A");
        q = t.clone();
    }
    println!("B");
}

```
 output: A(newline)in drop(newline)B(newline)in drop

### preview: wrapper objects as tool  {.smaller}


* to manage memory, make objects with custom <code>drop</code> functions
* creating object: allocates memory; droping: frees memory 
<hr class="vspace" />
* Rust compiler will insert drop calls automatically
* … and borrowing will enforce error if object still in use


### aside: RAII and C++  {.smaller}


* common C++ idea that Rust is copying: <br> <i>Resource Acquisition is Initialization</i> (RAII)
* will show ‘‘smart pointer’’ types where idea prominent in C++
* … but C++ lacks compiler borrowing/etc. enforcement 
<hr class="vspace" />
* idea probably didn't start with C++, though most prominent current version

