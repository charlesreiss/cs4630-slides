### multiple readers (1)

```rust
fn get_min_max(v: &Vec<i32>) -> (&i32, &i32) {
    let (mut min, mut max) = (&v[0], &v[0]);
    for i in 1..v.len() {
        if v[i] < *min { min = &v[i]; }
        if v[i] > *max { max = &v[i]; }
    }
    return (min, max);
}

fn main() {
    let vector = vec![1,2,3];
    let (min, max) = get_min_max(&vector);
    // min, max, println! below all borrowing vector
        // okay because both immutable references
    println!("vector = {:?}", vector);
    println!("min = {}; max = {}", *min, *max);
}
```


### multiple readers (2) {.smaller}

```rust
fn get_min_max(v: &Vec<i32>) -> (&i32, &i32) {
    let (mut min, mut max) = (&v[0], &v[0]);
    for i in 1..v.len() {
        if v[i] < *min { min = &v[i]; }
        if v[i] > *max { max = &v[i]; }
    }
    return (min, max);
}

fn main() {
    let (min, max);
    {
        let vector = vec![1,2,3];
        (min, max) = get_min_max(&vector);
        // OKAY:
        println!("min = {}; max = {}", *min, *max);
    }
    // ERROR:
    println!("min = {}; max = {}", *min, *max);
}
```

::: {.myoverbox .vlow .fragment}

```
error[E0597]: `vector` does not live long enough
  --> src/main.rs:14:34
   |
13 |         let vector = vec![1,2,3];
   |             ------ binding `vector` declared here
14 |         (min, max) = get_min_max(&vector);
   |                                  ^^^^^^^ borrowed value does not live long enough
15 |     }
   |     - `vector` dropped here while still borrowed
16 |     println!("min = {}; max = {}", *min, *max);
   |                                    ---- borrow later used here
```

:::

