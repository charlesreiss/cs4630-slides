### no multiple writers (1)

```rust
fn get_mut_min_max(v: &mut Vec<i32>) -> (&mut i32, &mut i32) {
    let (mut min, mut max) = (&mut v[0], &mut v[0]);  // ERROR
    for i in 1..v.len() {
        if v[i] < *min { min = &mut v[i]; }
        if v[i] > *max { max = &mut v[i]; }
    }
    return (min, max);
}
```

::: {.myoverbox .fragment .low}
```
error[E0499]: cannot borrow `*v` as mutable more than once at a time
 --> src/main.rs:2:47
  |
1 | fn get_mut_min_max(v: &mut Vec<i32>) -> (&mut i32, &mut i32) {
  |                       - let's call the lifetime of this reference `'1`
2 |     let (mut min, mut max) = (&mut v[0], &mut v[0]);
  |                                    -          ^ second mutable borrow occurs here
  |                                    |
  |                                    first mutable borrow occurs here
...
7 |     return (min, max);
  |            ---------- returning this value requires that `*v` is borrowed for `'1`
```
:::

### no multiple writers (2) {.smaller}


```rust
fn add1(vector: &mut Vec<u32>) {
    for value in vector {
        *value += 1
    }
}

fn foo() {
    let mut vector: Vec<u32> = vec![1, 2, 3];
    let first_elem: &u32 = &vector[0];
    println!("*first_elem is {}", *first_elem);
    add1(&mut vector);
    println!("*first_elem is {}", *first_elem); // ERROR
}
```

::: {.myoverbox .fragment .low}

```
error[E0502]: cannot borrow `vector` as mutable because it is also borrowed as immutable
  --> src/main.rs:11:10
   |
9  |     let first_elem: &u32 = &vector[0];
   |                             ------ immutable borrow occurs here
10 |     println!("*first_elem is {}", *first_elem);
11 |     add1(&mut vector);
   |          ^^^^^^^^^^^ mutable borrow occurs here
12 |     println!("*first_elem is {}", *first_elem);
   |                                   ----------- immutable borrow later used here
```

:::



### borrowing (3b)  {.smaller}


```rust
fn append1(vector: &mut Vec<u32>) {
    vector.push(1);
}

fn foo() {
    let mut vector: Vec<u32> = vec![1, 2, 3];
    let first_elem: &u32 = &vector[0];
    println!("*first_elem is {}", *first_elem);
    append1(&mut vector);
    println!("*first_elem is {}", *first_elem); // ERROR
}
```

::: {.myoverbox .low .fragment}

```
error[E0502]: cannot borrow `vector` as mutable because it is also borrowed as immutable
  --> src/main.rs:11:10
   |
9  |     let first_elem: &u32 = &vector[0];
   |                             ------ immutable borrow occurs here
10 |     println!("*first_elem is {}", *first_elem);
11 |     add1(&mut vector);
   |          ^^^^^^^^^^^ mutable borrow occurs here
12 |     println!("*first_elem is {}", *first_elem);
   |                                   ----------- immutable borrow later used here
```

:::


### aside: find the bug  {.smaller}


```c
struct vec { int *data; int size; };
void append1(struct vec *v) {
    v.data = realloc(v.data, sizeof(int) * (v.size + 1));
    v.data[v.size] = 1;
    v.size += 1;
}

void foo() {
    struct vec vector;
    vector.data = malloc(sizeof(int) * 3);
    vector.data[0] = 1; vector.data[1] = 2; vector.data[2] = 3;
    vector.size = 3;
    int *first_elem = &vector.data[0];
    printf("*first_elem is %d\n", *first_elem);
    append1(&vector);
    printf("*first_elem is %d\n"", *first_elem);
}

```


### borrowing (4a)  {.smaller}


```rust
fn add1(vector: &mut Vec<u32>) {
    for value in vector {
        *value += 1
    }
}

fn foo() {
    let mut vector: Vec<u32> = vec![1, 2, 3];
    // (lifetime of first_elem starts here)
    let first_elem: &mut u32 = &mut vector[0];
    *first_elem += 1;
    // (lifetime of first_elem ends here)
    add1(&mut vector);
    println!("vector is {:?}", vector);  // [3, 3, 4]
}

```


### borrowing (4b)  {.smaller}


```rust
fn add1(vector: &mut Vec<u32>) {
    for value in vector { *value += 1 }
}
fn foo() {
    let mut vector: Vec<u32> = vec![1, 2, 3];
    // (lifetime of first_elem starts here)
    let first_elem: &mut u32 = &mut vector[0];
    add1(&mut vector); 
    *first_elem += 1; // ERROR, two mutable borrowings of vector
    // (lifetime of first_elem ends here)
    println!("vector is {:?}", vector);  
}

```

::: {.myoverbox .vlow .fragment}

```
error[E0499]: cannot borrow `vector` as mutable more than once at a time
  --> src/main.rs:11:10
   |
9  |     let first_elem: &mut u32 = &mut vector[0];
   |                                     ------ first mutable borrow occurs here
10 |     *first_elem += 1;
11 |     add1(&mut vector);
   |          ^^^^^^^^^^^ second mutable borrow occurs here
12 |     println!("first_elem is {}", *first_elem);
   |                                  ----------- first borrow later used here
```

:::


### borrowing (4c)  {.smaller}


```rust
fn foo() {
    let mut vector: Vec<u32> = vec![1, 2, 3];
    let first_elem: &mut u32 = &mut vector[0];
    vector[1] += 2;  // ERROR: two mutable borrowings
    *first_elem += 1;
}
```

::: {.myoverbox .low .fragment}

```
error[E0499]: cannot borrow `vector` as mutable more than once at a time
  --> src/main.rs:10:5
   |
9  |     let first_elem: &mut u32 = &mut vector[0];
   |                                     ------ first mutable borrow occurs here
10 |     vector[1] += 2;
   |     ^^^^^^ second mutable borrow occurs here
11 |     *first_elem += 1;
   |     ---------------- first borrow later used here
   |
```

:::

