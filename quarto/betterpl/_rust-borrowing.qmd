
### borrowing (1)  {.smaller}


```rust
fn mysum(vector: &Vec<u32>) -> u32 {
    let mut total: u32 = 0
    for value in vector {
        total += value
    }
    return total
}

fn foo() {
    let vector: Vec<u32> = vec![1, 2, 3];
    let sum = mysum(&vector);
    // automates (vector, sum) = mysum(vector) idea
    
    println!("Sum is {}", sum);
    println!("vector[0] is {}" , vector[0]);
}
```



### dangling pointers? (1a)  {.smaller}


```c
int *dangling_pointer() {
    int array[3] = {1,2,3};
    return &array[0]; // not an error
}

```
<hr/>
```rust
fn dangling_pointer() -> &mut i32 {
    let mut array = vec![1,2,3];
    return &mut array[0]; // ERROR
}
```

::: {.myoverbox .fragment .low}

```
error[E0106]: missing lifetime specifier
  --> src/main.rs:19:25
   |
19 | fn dangling_pointer() -> &mut i32 {
   |                          ^ expected lifetime parameter
   |
   = help: this function's return type contains a borrowed value,
           but there is no value for it to be borrowed from
```

:::


### dangling pointers? (1b)  {.smaller}


```rust
/* 'static = "valid forever" */
fn dangling_pointer() -> &'static mut i32 {
    let mut array = vec![1,2,3];
    return &mut array[0]; // ERROR
}

```

::: {.myoverbox .fragment .low}

```
error[E0515]: cannot return value referencing local variable `array`
 --> src/lib.rs:4:12
  |
4 |     return &mut array[0]; // ERROR
  |            ^^^^^-----^^^
  |            |    |
  |            |    `array` is borrowed here
  |            returns a value referencing data owned by the current function
```

:::




### dangling pointers? (2)  {.smaller}


```c
int *ptr;
int dangling_pointer(int *array) {
    ptr = &array[0];
    return array[0];
}

```
<hr/>
```rust
static mut ptr : &i32 = &0;
fn dangling_pointer(v: Vec<i32>) -> i32 {
    ptr = &v[0];
    return v[0];
}

```

::: {.myoverbox .fragment fragment-index=1 .vlow}

```
error[E0133]: use of mutable static is unsafe
              and requires unsafe block
 --> src/lib.rs:3:5
  |
3 |     ptr = &v[0];
  |     ^^^ use of mutable static
  |
  = note: mutable statics can be mutated by
          multiple threads: aliasing violations
          or data races will cause undefined behavior
```

:::

::: {.myoverbox .fragment fragment-index=2 .vlow}

```
error[E0597]: `v` does not live long enough
 --> src/lib.rs:3:12
  |
2 | fn dangling_pointer(v: Vec<i32>) -> i32 {
  |                     - binding `v` declared here
3 |     ptr = &v[0];
  |     -------^---
  |     |      |
  |     |      borrowed value does not live long enough
  |     assignment requires that `v` is borrowed for `'static`
4 |     return v[0];
5 | }
  | - `v` dropped here while still borrowed
```

:::


### borrowing (2a)  {.smaller}


```rust
fn add1(vector: &mut Vec<u32>) {
    for value in vector {
        *value += 1
    }
}

fn foo() {
    let mut vector: Vec<u32> = vec![1, 2, 3];
    add1(&mut vector);
    println!("vector[0] is {}" , vector[0]);
}

```


### borrowing (2b)  {.smaller}


```rust
fn add1(vector: &mut Vec<u32>) {
    for value in vector {
        *value += 1
    }
}

fn foo() {
    let mut vector: Vec<u32> = vec![1, 2, 3];
    // what previous example was basically shorthand for
    {
        let borrowed = &mut vector;
        // borrowing vector here...
        add1(borrowed);
        // until here
    }
    println!("vector[0] is {}" , vector[0]);
}
```


### borrow tracking 


* compiler finds <i>lifetime</i> of borrowing 

   * when is new reference to object created
   * when is last use of reference to object

* compiler checks for overlap with all other borrowings of that object

