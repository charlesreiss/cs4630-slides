
### applying rules (1a)  {.smaller}



* single owner, someone can borrow temporarily
* only modify if exactly one user
 
:::: {.columns}

::: {.column width="50%"}
 
```rust
let mut x = 42;    // (1)
let p = &mut x;    // (2)
*p = 10;           // (3)
println!("{}", x); // (4)

```
 
:::

::: {.column width="50%"}
 
```c
int x = 42;        // (1)
int *p = &x;       // (2)
*p = 10;           // (3)
printf("%d\n", x); // (4)

```
 
:::

::::
 

* Exercise 1/2/3/4: The owner of x on line 1/2/3/4 is: 

   * A. (original owner) the variable x
   * B. (borrowed) the pointer/reference p



### applying rules (1b)  {.smaller}



* single owner, someone can borrow temporarily
* only modify if exactly one user
 
```rust
let x = vec![vec![1],vec![2]];
let y = &mut x[0];
let z = &mut y[0];
y.push(4);
x.push(vec![4]);
*z += 1;
y.push(5);

```
 

* exercise: what compile errors? how to fix?


### applying rules (2)  {.smaller}



* single owner, someone can borrow temporarily
* only modify if exactly one user
 
:::: {.columns}

::: {.column width="50%"}
 
```rust
let mut x = 42;    // (1)
let p = &mut x;    // (2)
*p = 10;           // (3)
println!("{}", x); // (4)
*p = 11;           // (5)

```
 
:::

::: {.column width="50%"}
 
```c
int x = 42;        // (1)
int *p = &x;       // (2)
*p = 10;           // (3)
printf("%d\n", x); // (4)
*p = 11;           // (5)

```

:::

::::
 

* Rust rufuses to compile left-side: x being used while borrowed by p
* Which changes would avoid this problem? 

   * A. use <code>*p</code> in the println!
   * B. make <code>p</code> mutable, reassign `p = &mut x` after line (4)
   * C. take a non-mutable reference to x instead of a mutable one


