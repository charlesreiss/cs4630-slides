
### PIE jump-table  


:::: {.columns}

::: {.column width="50%"}
<!-- \lstset{
    language=myasm,
    style=smaller,
    escapeinside=~~,
} -->
 
```{.gnuassembler code-line-numbers="|5-8"}
foo:
  movl	 $3, %eax
  cmpq	 $5, %rdi
  ja	 retDefault
  leaq	 jumpTable(%rip), %rax
  movslq (%rax,%rdi,4), %rdx
  addq	 %rdx, %rax
  jmp    *%rax
returnTwo:
  movl  $2, %eax
  ret
returnOne:
  movl  $1, %eax
defaultCase:
  ret

```

:::

::: {.column width="50%"}
<!-- \lstset{
    language={},
    style=smaller,
    escapeinside=~~,
} -->
 
```gnuassembler
  .section	.rodata
jumpTable:
  .long	returnOne-jumpTable
  .long	returnTwo-jumpTable
  .long	returnOne-jumpTable
  .long	returnTwo-jumpTable
  .long	returnOne-jumpTable
  .long	returnOne-jumpTable

```

:::

::::


### PIE jump-table

<!-- \lstset{
    language=myasm,
    style=smaller,
    escapeinside=~~,
} -->
 
```
00000000000007ab <foo>:
b8 03 00 00 00       	mov    $0x3,%eax
48 83 ff 05             cmp    $0x5,%rdi
77 1b                	ja     7d0 <foo+0x25>
48 8d 05 ab 00 00 00 	lea    0xab(%rip), %rax        # 868
48 63 14 b8          	movslq (%rax,%rdi,4), %rdx
48 01 d0             	add    %rdx,%rax
ff e0                	jmpq   *%rax
b8 02 00 00 00       	mov    $0x2,%eax
c3                   	retq   
b8 01 00 00 00       	mov    $0x1,%eax
c3                   	retq
...
@ 868: -156 /* offset */
@ 870: -162
...

```


### added cost  {.smaller}


* replace <code>jmp *jumpTable(,%rdi,8)</code> 
<hr class="vspace" />
* with:
* <code>lea</code> (get table address --- with relative offset)
* <code>movslq</code> (do table lookup of offset)
* <code>add</code> (add to base)
* <code>jmp</code> (to computed base)


### 32-bit x86 is worse (1) 



* no relative addressing for <code>mov</code>, <code>lea</code>, …
* even changes ‘‘stubs’’ for printf:
 <!-- \lstset{
    language=myasm,
    style=smaller,
    escapeinside=~~,
} -->
 
```
// BEFORE: (fixed addresses)
08048310 <__printf_chk@plt>:
 8048310: ff 25 10 a0 04 08  jmp    *0x804a010
    /* 0x804a010 == global offset table entry */

// AFTER: (position-independent)
00000490 <__printf_chk@plt>:
 490:	ff a3 10 00 00 00    jmp    *0x10(%ebx)
    /* %ebx --- address of global offset table */
    /* needs to be set by caller */

```

### 32-bit x86 is worse (2) 


```
// BEFORE: (fixed addresses)
 8049061:  68 08 a0 04 08      push   $0x804a008
 8049066:  e8 d5 ff ff ff      call   8049040 <puts@plt>

// AFTER: (position-independent)
000010d0 <__x86.get_pc_thunk.bx>:
    10d0:  8b 1c 24            mov    (%esp),%ebx
    10d3:  c3                  ret
...

    106e:  e8 5d 00 00 00      call   10d0 <__x86.get_pc_thunk.bx>
    1073:  81 c3 65 2f 00 00   add    $0x2f65,%ebx
...
    107d:  8d 83 30 e0 ff ff   lea    -0x1fd0(%ebx),%eax
    1083:  50                  push   %eax
    1084:  e8 b7 ff ff ff      call   1040 <puts@plt>

```

