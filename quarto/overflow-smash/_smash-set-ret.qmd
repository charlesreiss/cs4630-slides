
### setting return address (diagram) 

<!-- FIXME: maybe this diagram could be in HTML? -->

::: {.r-stack .my-full}

![](/overflow-smash/texfig/smash-set-ret.figure-1.svg){.fragment .fade-out fragment-index=1 fig-alt="The stack layout has the initial stack pointer with main's stuff on top, then usage by other functions, then the 'vulnerable' function return addr, then the 'vulnerable' function buffer, then other variables in the vulnerable function, then scanf's stuff"}

![](/overflow-smash/texfig/smash-set-ret.figure-2.svg){.fragment .fade-in-then-out fragment-index=2 fig-alt="for now, the assumption is the initial stack pointer is fixed."}

![](/overflow-smash/texfig/smash-set-ret.figure-3.svg){.fragment .fade-in-then-out fragment-index=3 fig-alt="the region starting from the beginning of the vulnerable buffer, through vulnerable's reutrn address and overlapping other functoin's stuff is overwritten by the attack"}

![](/overflow-smash/texfig/smash-set-ret.figure-4.svg){.fragment .fade-in-then-out fragment-index=4 fig-alt="shellcode is located around the beginning of the vulnerable buffer, if it's at the start of the attack input"}

![](/overflow-smash/texfig/smash-set-ret.figure-5.svg){.fragment .fade-in-then-out fragment-index=5 fig-alt="we could compute the distance from the initial stack pointer to the shellcode by carefully reading the assembly of the involved functions (starting with main and going through the functions it calls that eventually call vulnerable)"}

![](/overflow-smash/texfig/smash-set-ret.figure-6.svg){.fragment .fade-in-then-out fragment-index=6 fig-alt="we can compute the distance from vulnerable's return address to the beginning of the buffer by reading vulnerable's assembly"}

![](/overflow-smash/texfig/smash-set-ret.figure-7.svg){.fragment .fade-in-then-out fragment-index=7 fig-alt="in gdb we use 'b vulnerable', then 'run', then 'info registers' to see the value of the stack pointer (rsp) when vulnerable starts, which will point to vulnerable's return address}

:::

