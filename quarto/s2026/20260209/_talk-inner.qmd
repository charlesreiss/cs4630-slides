### last time

*  "packer" / "encrypted code" idea
*  handling packers via virtualization/emuatlion/scanning memory
*  malware detecting virtualization
   *  weird devices / unimplemented behavior
   *  exceeding resources in virtual enviornment
   *  only doing malicious thing rarely
*  "decrypter" templates with multiple choices
   *  idea of lots of random no-operations

### quiz Q1 (1)

*  idea: instead of doing call to printf, run virus code elsewhere
*  for program to work the same, virus code needs to run printf
<hr />
*  printf address is in the global offset table
*  want to read global offset table entry and call it
*  `jmp *GOT_ENTRY`
   *  `jmp *X(%rip)`  --- `X` needs to be selected based on where jmp is

### quiz Q1 (2)

*  `push $0x404018; ret` --- returns to 0x404018
   *  tries to run function pointer as machine code
*  `mov 0x404018, %rax; jmp *%rax`; loads memory[0x404018] into `%rax`

### quiz Q4

*  option 1 was grammatically poor (so dropped), but...
*  obfuscated machine code is still fixed
   *  can have new pattern that matches it, using only fixed string matching

### assignment Q+A

## exercise: limitations of generic anti-packer {visibility="hidden"}

{{< include /antianti/_packer-detect-limit-ex.qmd >}}

## more generic mutation {visibility="hidden"}

{{< include /antianti/_mutation-engine-generic.qmd >}}

# metamorphic viruses {visibility="hidden"}

{{< include /antianti/_meta-intro.qmd >}}

## example: changing bodies {visibility="hidden"}

{{< include /antianti/_meta-body-change-example.qmd >}}

## case study: Evol {visibility="hidden"}

{{< include /antianti/_evol.qmd >}}

## handling relocation with mutation {visibility="hidden"}

{{< include /antianti/_mutate-reloc.qmd >}}

## fancy mutation engines {visibility="hidden"}

{{< include /antianti/_fancy-mutation-engine.qmd >}}

# goats and anti-goat {visibility="hidden"}

{{< include /antianti/_goat.qmd >}}


# anti-debugging {visibility="hidden"}

### diversion: debuggers

* we'll care about two pieces of functionality: 
<hr class="vspace" />
* <em>breakpoints</em>
   * debugger gets control when certain code is reached
* single-step
   * debugger gets control after a single instruction runs

## breaking breakpoints {visibility="hidden"}

{{< include /antianti/_antidebug-breakpt-int3.qmd >}}

## aside: modern breakpoints{visibility="hidden"}

{{< include /antianti/_debug-modern-breakpt.qmd >}}

### diversion: debuggers

* we'll care about two pieces of functionality: 
<hr class="vspace" />
* breakpoints
   * debugger gets control when certain code is reached
* <em>single-step</em>
   * debugger gets control after a single instruction runs


## breaking single-stepping (short) {visibility="hidden"}

{{< include /antianti/_antidebug-ss.qmd >}}

# emulation-based obfuscation {visibility="hidden"}

{{< include /antianti/_emulate-obfuscate.qmd >}}

# retroviruses / direct antiantivirus {visibility="hidden"}

{{< include /antianti/_retro.qmd >}}

## hiding {visibility="hidden"}

{{< include /antianti/_stealth.qmd >}}

## chkrootkit {visibility="hidden"}

{{< include /antianti/_chkrootkit.qmd >}}

{{< include /command-inj/_talk-inner.qmd >}}

{{< include /taint/_talk-inner.qmd >}}

{{< include /overflow-basic/_talk-inner.qmd >}}

<!-- {{< include /overflow-smash/_talk-inner.qmd >}} -->

# backup slides {visibility="hidden"}

### backup slides 

## aside: disinfection {visibility="hidden"}

{{< include /heur-detect/_aside-disinfect.qmd >}}

## signatures and extracting encryptd code? {visibility="hidden"}

{{< include /antianti/_encrypted-code-sigs-analyze.qmd >}}

# backup slides {visibility="hidden"}

### backup slides 


<!-- {{< include /virus/_talk-backup.qmd >}} -->
