
### stubs  {.smaller}

<pre><code>0000000000001050 &lt;puts@plt&gt;:
    1050:       f3 0f 1e fa             endbr64 
    1054:       f2 ff 25 75 2f 00 00    bnd jmpq *0x2f75(%rip)        # 3fd0 &lt;puts@GLIBC_2.2.5&gt;
    <em> replace with: </em>
0000000000001050 &lt;puts@plt&gt;:
    1050:       f3 0f 1e fa             endbr64 
    1054:       ff 25 XX XX XX XX       jmp VIRUS CODE
    105a:       90                      nop
</code></pre>
 

* in known location (particular section of executable)


### stubs again  {.smaller}

<pre><code>0000000000001050 &lt;puts@plt&gt;:
    1050:       f3 0f 1e fa             endbr64 
    1054:       f2 ff 25 75 2f 00 00    bnd jmpq *0x2f75(%rip)        # 3fd0 &lt;puts@GLIBC_2.2.5&gt;
</code></pre>
 

* don't edit stub --- edit initial value at <code>0x3fd0</code> 

   * stored in data section of executable

* originally: pointer to lazy linking code 

* malware code can jump to original lazy linking code after 

* preview of future topics: also can be changed by exploits 

   * commonly involved in memory-error exploits (buffer overflow, etc.)



### relocations?  {.smaller}

on executable: <pre><code>hello.exe:     file format elf64-x86-64

DYNAMIC RELOCATION RECORDS
OFFSET           TYPE              VALUE 
...
0000000000003fd0 R_X86_64_JUMP_SLOT  <it>puts@GLIBC_2.2.5</it>
    <em>replace with:</em>
0000000000003fd0 R_X86_64_JUMP_SLOT  <it>*ABS*+virus_code_address</it>
...
</code></pre>
 

* relocation record: where to put library code addresses


### symbols?  {.smaller}

on library: <pre><code>/lib/x86_64-linux-gnu/libc.so.6:     file format elf64-x86-64

DYNAMIC SYMBOL TABLE:
...
00000000000875a0  w   DF .text  <it>00000000000001dc</it>  GLIBC_2.2.5 puts
    <em>replace with:</em>
00000000000875a0  w   DF .text  <it>(virus code off)</it>  GLIBC_2.2.5 puts
</code></pre>
 

* symbol table entry: where library code is

