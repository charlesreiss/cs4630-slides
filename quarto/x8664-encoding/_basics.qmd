
### x86 instruction encoding 


* x86-64 encoding is quite complicated
* reason we don't teach it in CS 2130 

* mostly complicated because of <it>history</it>


### the 8086  {.smaller}


![](/x8664-encoding/Intel8086.jpg){}
 

* 1979 Intel processor
* 4 general purpose 16-bit registers: AX, BX, CX, DX
* 4 special 16-bit registers: SI, DI, BP, SP


### 8086 instruction encoding: simple 


* special cases: 1-byte instructions: 

   * anything with no arguments
   * push ax, push bx, push cx, … (dedicated opcodes)
   * pop ax, …



### 8086 instruction encoding: two-arg  {.smaller}


* 1-byte opcode
* sometimes <code>ModRM</code> byte: 

   * 2-bit ‘‘mod’’ and
   * 3-bit register number (source or dest, depends on opcode) and
   * 3-bit ‘‘r/m’’ (register or memory)

* ‘‘mod’’ + ‘‘r/m’’ specify one of: 

   * <code>%reg</code> (mod = <code>11</code>)
   * <code>(%bx/%bp, %si/%di)</code>
   * <code>(%bx/%si/%di)</code>
   * <code>offset(%bx/%bp/,%si/%di)</code> (8- or 16-byte offset)

* non-intuitive table


### 16-bit ModRM table 


::: {.r-stack .my-full}
![](texfig/basics-16-bit-modrm-table.figure-1.svg){.fragment .fade-in-then-out fragment-index=1}

![](texfig/basics-16-bit-modrm-table.figure-2.svg){.fragment .fade-in-then-out fragment-index=2}

:::


### 8086 evolution 


* Intel 8086 --- 1979, 16-bit registers
* Intel (80)386 --- 1986, 32-bit registers
* AMD K8 --- 2003, 64-bit registers


### x86 modes  {.smaller}


* x86 has multiple <em>modes</em>
* maintains compatiblity
* e.g.: modern x86 processor can work like 8086 

   * called ‘‘real mode’’

* different mode for 32-bit/64-bit
* same basic encoding; some sizes change


### 32-bit ModRM table 


::: {.r-stack .my-full}
![](texfig/basics-32-bit-modrm-table.figure-1.svg){.fragment .fade-in-then-out fragment-index=1}

![](texfig/basics-32-bit-modrm-table.figure-2.svg){.fragment .fade-in-then-out fragment-index=2}

:::


### 32-bit addition: SIB bytes  {.smaller}


* 8086 addressing modes made registers different
* 32-bit mode got rid of this (mostly)
* problem: not enough spare bits in <code>ModRM</code> byte
* solution: if ‘‘r/m’’ bits = <code>100</code> (4, normally ESP), extra ‘‘SIB’’ byte: 

   * 2 bit [scale]{.fragment fragment-index=2 .custom .myem-only}: <code>00</code> is 1, <code>01</code> is 2, <code>10</code> is 4, <code>11</code> is 8
   * 3 bit [index]{.fragment fragment-index=3 .custom .myem-only}: index register number
   * 3 bit [base]{.fragment fragment-index=4 .custom .myem-only}: base register number

* <code>([%baseReg]{.fragment fragment-index=4 .custom .myem-only},[%indexReg]{.fragment fragment-index=3 .custom .myem-only},[scale]{.fragment fragment-index=2 .custom .myem-only})</code>


### intel manual: SIB table 


![](/x8664-encoding/32bitsib){}


### basic 32-bit encoding  {.smaller}

![](texfig/basics-basic-32-bit-encoding.figure.svg)
 

* dashed: not always present
* opcodes: 1-3 bytes 

   * some 5-bit opcodes, with 3-bit register field
   * (alternate view: 8-bit opcode with fixed register)
   * sometimes Reg part of ModRM used as add'tl part of opcode

* displacement, immediate: 1, 2, or 4 bytes 

   * or, rarely, 8 bytes


