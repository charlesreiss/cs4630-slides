\section{running example}
\input{../re-tools/run-example}

\section{finding strings}

\input{../re-tools/ex-strings}

\section{finding library/system calls}

    % FIXME: objdump -R
    % FIXME: objdump -t

\input{../re-tools/lib-syscall}

\section{disassembly, need for xrefs}
\input{../re-tools/where-is-code}

\section{cross-references}
\input{../re-tools/xrefs}

\section{high-level overviews}

\subsection{function callers/callees}
\input{../re-tools/function-call-callee} % FIXME: cleanup exercise

\subsection{control flow graphs}
\input{../re-tools/func-graphs}

\subsection{arrows on the side}
\input{../re-tools/side-arrows}

\section{decompiling}

\subsection{decompiler}
\input{../re-tools/decomp-ex}

% intermediate representation for main() function in mystery
% decompiled representation
\subsection{Ghidra: intermediate representation}
\input{../re-tools/ghidra-ir}

\section{patching things}
\input{../re-tools/patch}

\section{on/with debuggers}
\input{../re-tools/debuggers} % FIXME: screenshots
% FIXME: 
    % remote gdb/lldb
    % taking snapshots and going back to them
    % aside: gdb reverse gdb support

% FIXME: outline for symbolic exec example
    % simple foo(x) { ... } how is X reached?
    % solving for variable
    % then show angr doing this with actual example
    % show automating path in some complex code with angr

    % 
