\begin{frame}{fuzzing/symbolic exec imprecision}
    \begin{itemize}
    \item symbolic execution had some nice properties:
        \begin{itemize}
        \item could reliably enumerate possible paths
        \item could figure out inputs
        \item could prove paths are impossible
        \end{itemize}
    \item but had huge practical problems:
        \begin{itemize}
        \item not enough time/space to explore all those paths
        \item too complicated to actually solve equations to find inputs
        \end{itemize}
    \vspace{.5cm}
    \item greybox fuzzing: one practical compromise
        \begin{itemize}
        \item replaced equation solving with (educated) guessing
        \item tried to explore enough paths
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{complete versus sound}
    \begin{itemize}
        \item complete:
            \begin{itemize}
            \item if way to reach assertion failure, analysis finds it
            \end{itemize}
        \item sound:
            \begin{itemize}
            \item if analysis finds way to reach assertion failure, it's fails the assertion
            \end{itemize}
        \vspace{.5cm}
        \item symbolic execution, greybox fuzzing: always sound
            \begin{itemize}
            \item because they actually run the program
            \end{itemize}
        \item symbolic execution: complete \textbf{if all paths are solved}
            \begin{itemize}
            \item but that isn't practical for a large program
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{other program analysis designs}
    \begin{itemize}
    \item other design points than symbolic execution:
    \vspace{.5cm}
    \item tracking \myemph{all the varaible values}
    \item alternative: \myemph{just track properties of interest}
    \vspace{.5cm}
    \item compute precisely \myemph{what paths through code are possible}
    \item alternative: \myemph{use some approximation}
    \end{itemize}
\end{frame}
