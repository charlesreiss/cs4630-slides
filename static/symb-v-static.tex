\begin{frame}{fuzzing/symbolic exec imprecision}
    \begin{itemize}
    \item symbolic execution had some nice properties:
        \begin{itemize}
        \item could reliably enumerate possible paths
        \item could figure out inputs
        \item could prove paths are impossible
        \end{itemize}
    \item but had huge practical problems:
        \begin{itemize}
        \item not enough time/space to explore all those paths
        \item too complicated to actually solve equations to find inputs
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{complete versus sound}
    \begin{itemize}
        \item complete:
            \begin{itemize}
            \item if way to reach assertion failure, analysis finds it
            \end{itemize}
        \item sound:
            \begin{itemize}
            \item if analysis finds way to reach assertion failure, it's fails the assertion
            \end{itemize}
        \vspace{.5cm}
        \item greybox fuzzing, symbolic exec \textit{without approximations}: always sound
            \begin{itemize}
            \item because they actually run the program
            \end{itemize}
        \item symbolic execution without approximations: complete \textbf{if all paths are solved}
            \begin{itemize}
            \item but that isn't practical for a large program
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{other program analysis designs}
    \begin{itemize}
    \item other design points than symbolic execution:
    \vspace{.5cm}
    \item not tracking \myemph{all the variable values}
    \item alternative: \myemph{just track properties of interest}
    \vspace{.5cm}
    \item compute precisely \myemph{what paths through code are possible}
    \item alternative: \myemph{track sub/superset of possible paths}
        \begin{itemize}
        \item superset = find false positives; subset = false negatives
        \end{itemize}
    \end{itemize}
\end{frame}
